import { NextResponse } from 'next/server'
import { createHmac } from 'node:crypto'

/**
 * NOWPayments IPN (webhook) handler
 * - Validates HMAC-SHA512 signature from 'x-nowpayments-sig'
 * - Accepts only 'confirmed' or 'finished' payments
 * - Updates an existing pending transaction if found (by product_id + email)
 *   otherwise inserts a new 'confirmed' transaction
 */
export async function POST(req) {
  // Read RAW body first (required for correct signature verification)
  const raw = await req.text()
  const ipnSecret = process.env.NOWPAYMENTS_IPN_SECRET || ''
  const receivedSig = req.headers.get('x-nowpayments-sig') || ''

  // Compute signature: HMAC-SHA512(rawBody, IPN_SECRET)
  const computedSig = createHmac('sha512', ipnSecret).update(raw).digest('hex')

  if (!ipnSecret || !receivedSig || receivedSig !== computedSig) {
    console.warn('NOWPayments webhook: invalid signature')
    return NextResponse.json({ error: 'Invalid signature' }, { status: 403 })
  }

  // Parse the verified payload
  let payload
  try {
    payload = JSON.parse(raw)
  } catch {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 })
  }

  const {
    payment_id,
    payment_status,
    pay_address,           // pay-in address generated by NOWPayments
    price_amount,          // amount in the merchant currency (e.g. MATIC)
    price_currency,        // 'matic', 'eth', ...
    customer_email,
    order_id,              // we set this as `${product_id}_${timestamp}`
  } = payload

  // We only act on completed states
  const doneStatuses = new Set(['confirmed', 'finished'])
  if (!doneStatuses.has((payment_status || '').toLowerCase())) {
    // Acknowledge but do nothing (NOWPayments will stop retrying)
    return NextResponse.json({ message: `Ignored status: ${payment_status}` }, { status: 200 })
  }

  if (!order_id) {
    return NextResponse.json({ error: 'Missing order_id' }, { status: 400 })
  }

  const productId = order_id.split('_')[0]
  const chain = (price_currency || '').toString().toUpperCase() || null
  const amount = price_amount

  // Supabase REST config
  const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL
  const SUPABASE_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  const headers = {
    'Content-Type': 'application/json',
    apikey: SUPABASE_KEY,
    Authorization: `Bearer ${SUPABASE_KEY}`,
  }

  try {
    // 1) Try to find an existing pending transaction for this product + email
    let existing = null
    if (customer_email) {
      const q = new URLSearchParams({
        select: '*',
        product_id: `eq.${productId}`,
        email: `eq.${customer_email}`,
        status: 'eq.pending',
        limit: '1',
      })
      const findRes = await fetch(`${SUPABASE_URL}/rest/v1/transactions?${q.toString()}`, {
        headers,
        cache: 'no-store',
      })
      if (findRes.ok) {
        const arr = await findRes.json()
        existing = arr?.[0] || null
      }
    }

    if (existing?.id) {
      // 2a) Update the pending one to confirmed
      const patchRes = await fetch(
        `${SUPABASE_URL}/rest/v1/transactions?id=eq.${existing.id}`,
        {
          method: 'PATCH',
          headers,
          body: JSON.stringify({
            status: 'confirmed',
            wallet_address: pay_address,
            chain,
            amount,
          }),
        }
      )
      if (!patchRes.ok) {
        const txt = await patchRes.text()
        console.error('Supabase PATCH failed:', txt)
        return NextResponse.json({ error: 'Failed to update transaction' }, { status: 500 })
      }
    } else {
      // 2b) No pending row found → insert a new confirmed transaction
      const postRes = await fetch(`${SUPABASE_URL}/rest/v1/transactions`, {
        method: 'POST',
        headers: { ...headers, Prefer: 'return=representation' },
        body: JSON.stringify({
          product_id: productId,
          wallet_address: pay_address,
          chain,
          amount,
          status: 'confirmed',
          email: customer_email || null,
        }),
      })
      if (!postRes.ok) {
        const txt = await postRes.text()
        console.error('Supabase INSERT failed:', txt)
        return NextResponse.json({ error: 'Failed to insert transaction' }, { status: 500 })
      }
    }

    // All good — acknowledge to NOWPayments
    return NextResponse.json({
      ok: true,
      payment_id,
      order_id,
      status: payment_status,
    })
  } catch (err) {
    console.error('Webhook processing error:', err)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

